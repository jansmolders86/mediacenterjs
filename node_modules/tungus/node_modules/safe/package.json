{
  "author": {
    "name": "Sergey Korotkov",
    "email": "sergeyksv@gmail.com"
  },
  "name": "safe",
  "version": "0.0.9",
  "repository": {
    "type": "git",
    "url": "git://github.com/sergeyksv/safejs.git"
  },
  "contributors": [],
  "main": "./lib/safe",
  "engines": {
    "node": ">= v0.4.x"
  },
  "dependencies": {},
  "devDependencies": {},
  "readme": "Module provides set of handy function to deal with thrown errors, callbacks and\nnodejs alike error passing (first function argument). \n\nThe goal is to make code more stable (by catching thrown exception) and avoid\nsome routine calls. Idea is inspired in Step library which catches error and\nconvert them into callback function calls. Async library which appears more\nhandy for dealing with async functions (has reacher functionality)  missing this.\nWith safe library it is easy to plug-in this when required.\n\nFunction are kind of chainable, so instead of `safe.trap(safe.sure(function () {} ))`\nit is possible to use `safe.trap_sure(function() {})`\n\n### Plain poor code:\n\tasync.series([\n\t\tfunction (callback) {\n\t\t\t// .. do something that can throw error\n\t\t\t// BAD: some dirty code can throw exception here\n\t\t\t// which breaks nodejs server\n\t\t\tasync.forEach(array, function (e, callback2) {\n\t\t\t\tsome.getSome(e.id, function (err, some) {\n\t\t\t\t\t// BAD: err is not checked \n\t\t\t\t\t// .. process some\n\t\t\t\t\t// BAD: boring code\n\t\t\t\t\tcallback2();\n\t\t\t\t})\n\t\t\t},callback)\n\t\t}]\n\n### Plain good code:\n\tasync.series([\n\t\tfunction (callback) {\n\t\t\ttry {\n\t\t\t\t// .. do something that can throw error\n\t\t\t\t// .. note ANY CODE CAN DO in some conditions\n\t\t\t\tasync.forEach(array, function (e, callback2) {\n\t\t\t\t\tsome.getSome(e.id, function (err, some) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (err) return callback2(err);\n\t\t\t\t\t\t\t// .. process some\n\t\t\t\t\t\t\tcallback2();\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tcallback2(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},callback)\n\t\t\t} catch (err) {\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t}]\n\n###  Safe enhanced good code:\n\tasync.series([\n\t\tsafe.trap(function (callback) {\n\t\t\tasync.forEach(array, function (e, callback2) {\n\t\t\t\tsome.getSome(e.id, safe.trap_sure_results(callback2, function (some) {\n\t\t\t\t\t// .. process some\n\t\t\t\t});\n\t\t\t},callback)\n\t\t}\n\nWe also found that in some simple cases safe functions allows to write\ncode that does things similar to async.series or async.waterfall in bit \nmore efficient way (at least as we think). It became possible\nbecause JavaScript closures are in effect and you not need to think how\nto pass variables from one function to another. In theory async.waterfall should\nhelp for such case but it has two caveats. First is when one of funtions\nthat you used change number of paramaters returned thru callback. Code became\nbroken and error is hard to find. Second one is that if result of one step\nis required later then next step you have to pass it thru intermidiate\nsteps which makes waterfall behavior fall down to async.series. Check \nthis on examples\n\n#### Classic async.series\n\t\tvar users, user, clients;\n\t\tasync.series([\n\t\t\tfunction (callback) {\n\t\t\t\tmongo.collection(\"users\",function (err,val) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tusers = val;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (callback) {\n\t\t\t\tusers.findOne({login:\"john\"},fuction (err, val) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tsession.user = user;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction (callback) {\n\t\t\t\tmongo.collection(\"clients\",function (err,val) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tclients = val;\n\t\t\t\t})\n\t\t\t},\n\t\t\tfunction (callback) {\n\t\t\t\tclients.insert({uid:user.id, date: new Date()},callback)\n\t\t\t}\n\t\t], function (err) {\n\t\t\tif (err) callback(new Error(\"Log-in or password is incorrect\")\n\t\t\t\telse callback();\n\t\t}))\n\t\t\n#### Classic async.waterfall\n\t\tasync.waterfall([\n\t\t\tfunction (callback) {\n\t\t\t\tmongo.collection(\"users\",callback)\n\t\t\t},\n\t\t\tfunction (users,callback) {\n\t\t\t\tusers.findOne({login:\"john\"},callback)\n\t\t\t},\n\t\t\tfunction (user,callback) {\n\t\t\t\tmongo.collection(\"clients\",function (err, clients) {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null,user,clients)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction (user,clients,callback) {\n                                sesson.user = user;\n\t\t\t\tclients.insert({uid:user.id, date: new Date()},callback)\n\t\t\t}\n\t\t], function (err) {\n\t\t\tif (err) callback(new Error(\"Log-in or password is incorrect\")\n\t\t\t\telse callback();\n\t\t}))\t\t\n\n#### Safe enhanced\n\t\tsafe.run(function(callback) {\n\t\t\tmongo.collection(\"users\",safe.sure(callback, function (users) {\n\t\t\t\tusers.findOne({login:\"john\"},safe.sure(callback, fuction (user) {\n\t\t\t\t\tsession.user = user;\n\t\t\t\t\tmongo.collection(\"clients\",safe.sure(callback, function (clients) {\n\t\t\t\t\t\tclients.insert({uid:user.id, date: new Date()},callback)\n\t\t\t\t\t}))\n\t\t\t\t}))\n\t\t\t}))\n\t\t}, function (err) {\n\t\t\tif (err) callback(new Error(\"Log-in or password is incorrect\")\n\t\t\t\telse callback();\n\t\t}))\n\n\n### API\n\n#### yield\nYields execution of function giving chance to other stuff run\n\n@param {Function} callback\n\n#### noop\nEmpty function, does nothing. Sometime useful.\n\n#### back\nRun provided callback in next tick of event loop. This is what for\nprocess.nextTick was usually used. However for very strange reason\nstarting from node v10 it fails when called recursively. \n\nTo be honest its failry stupid because now process.nextTick became\nuseless because will it work or not depends on callee. It was honest\njust to say to stop use process.nextTick, there is no any purpose for\nit any longer. Function safe.run will use process.nextTick or its new successor\nsetImmediate in newer versions of node.\n\nAnyway process.nextTick usually was used to break recursion or to maintain async\nbehavior when function return something right away without calling\ntrully async function (IO mostly). It was required to write something\nlike:\n\n\tif (cached)\n\t\treturn process.nextTick(function () {callback(null,cached})\nwith back:\n\n\tif (cached)\n\t\treturn safe.back(callback,null,cached) \n\n@param {Function} callback\n@param argument1\n@param argumentN\n\n#### result\nTransform synchronious function call result to callback\n\n_callback is optional, when omited (function get one parameter) it assumes\ncallback as last parameter of wrapped function_\n\n@param {Function} callback or wrapped function\n@param {Function} fn wrapped function\n\n\n#### sure\nStrip (hide) first parameter from wrapped function and ensure that\ncontroll is passed to it when no error happpens. I.e. it does do\nroutine error check `if (err) return callback(err)`\n\n_callback is optional, when omited (function get one parameter) it assumes\ncallback as last parameter of wrapped function_\n\n@param {Function} callback or wrapped function\n@param {Function} wrapped function\n\n#### trap\nWrap function call into try catch, pass thrown error to callback\n\n_callback is optional, when omited (function get one parameter) it assumes\ncallback as last parameter of wrapped function_\n\n@param {Function} callback or wrapped function\n@param {Function} fn wrapped function\n\n#### run\nRun function with provided callback. Just help to have better readability.\nUsefull when you need to handle local callback results, even if there are\nerrors. \n\n@param {Function} wrapped function\n@param {Function} callback\n\n#### pseudo chains\n\nUnderscore chains like trap_safe, trap_safe_result are possible\n",
  "readmeFilename": "README.md",
  "_id": "safe@0.0.9",
  "description": "Module provides set of handy function to deal with thrown errors, callbacks and nodejs alike error passing (first function argument).",
  "dist": {
    "shasum": "d25868d29a0970acd7d946147521ec7671510d71"
  },
  "_from": "safe@>=0.0.9"
}
